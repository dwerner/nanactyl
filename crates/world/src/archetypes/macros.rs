/// This macro is intended to do the heavy lifting and ensure that there is a
/// single consistent list of fields that make up an archetype. Several structs
/// will be generated:
/// - <base_name>Archetype - stores and owns the data.
/// - <base_name>Ref - a reference to a single item in the archetype.
/// - <base_name>Builder - a builder for spawning an item in the archetype.
/// - <base_name>Iterator - an iterator over the archetype data.
/// - <base_name>Index - an index into the archetype.
/// - <base_name>Error - an error type for the archetype.
macro_rules! def_archetype_boilerplate {
    ($base_name:ident, $($field:ident : $type:ty),*) => {
        paste::paste! {
            /// Generated by `def_archetype!` macro.
            #[doc = "Archetype `" [<$base_name Archetype>] "` object."]
            #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
            pub struct [<$base_name Archetype>] {
                /// Default builder for this archetype
                default_builder: Option<[<$base_name Builder>]>,
                len: usize,
                $(
                    pub $field : Vec<$type>,
                )*
            }

            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
            pub struct [<$base_name Index>](u32);

            impl From<u32> for [<$base_name Index>] {
                fn from(value: u32) -> Self {
                    Self(value)
                }
            }

            impl From<usize> for [<$base_name Index>] {
                fn from(value: usize) -> Self {
                    Self(value as u32)
                }
            }

            impl From<[<$base_name Index>]> for usize {
                fn from(value: [<$base_name Index>]) -> Self {
                    value.0 as usize
                }
            }

            #[derive(thiserror::Error, Debug)]
            pub enum [<$base_name Error>] {
                #[error("builder is incomplete {builder:?}")]
                IncompleteBuilder { builder: [<$base_name Builder>] },
            }

            impl Default for [<$base_name Archetype>] {
                fn default() -> Self {
                    Self {
                        len: 0,
                        default_builder: Default::default(),
                        $(
                            $field : Vec::new(),
                        )*
                    }
                }
            }

            pub struct [<$base_name Ref>]<'a> {
                $(
                    pub $field : &'a mut $type,
                )*
            }

            #[derive(Debug, Default, Clone, serde::Serialize, serde::Deserialize)]
            pub struct [<$base_name Builder>] {
                $(
                    $field: Option<$type>,
                )*
            }

            impl [<$base_name Builder>] {
                $(
                    #[doc = "Set the `" $field "` field in this builder."]
                    pub fn [<set_ $field>](&mut self, $field: $type) {
                        self.$field = Some($field);
                    }
                )*
            }

            pub struct [<$base_name Iterator>]<'a> {
                $(
                    $field : core::slice::IterMut<'a, $type>,
                )*
            }

            impl<'a> Iterator for [<$base_name Iterator>]<'a> {
                type Item = [<$base_name Ref>]<'a>;
                fn next(&mut self) -> Option<Self::Item> {
                    Some([<$base_name Ref>] {
                        $(
                            $field : self.$field.next()?,
                        )*
                    })
                }
            }

            impl crate::Archetype for [<$base_name Archetype>] {
                type Index = [<$base_name Index>];
                type ItemRef<'a> = [<$base_name Ref>]<'a>;
                type IterMut<'a> = [<$base_name Iterator>]<'a>;
                type Builder = [<$base_name Builder>];
                type Error = [<$base_name Error>];

                fn len(&self) -> Self::Index {
                    self.len.into()
                }

                fn iter_mut(&mut self) -> Self::IterMut<'_> {
                    [<$base_name Iterator>] {
                        $(
                            $field: self.$field.iter_mut(),
                        )*
                    }
                }

                fn get_mut(&mut self, index: Self::Index) -> Option<Self::ItemRef<'_>> {
                    let index: usize = index.into();
                    Some([<$base_name Ref>] {
                        $(
                            $field: self.$field.get_mut(index)?,
                        )*
                    })
                }

                fn builder(&self) -> Self::Builder {
                    match self.default_builder.clone() {
                        Some(builder) => builder,
                        None => Self::Builder {
                            $(
                                $field: None,
                            )*
                        }
                    }
                }

                fn set_default_builder(&mut self, builder: Self::Builder) {
                    self.default_builder = Some(builder);
                }

                fn spawn(&mut self, builder: Self::Builder) -> Result<Self::Index, Self::Error> {
                    self.len += 1;
                    match builder {
                        Self::Builder {
                            $(
                                $field: Some($field),
                            )*
                        } => {
                            $(
                                self.$field.push($field);
                            )*
                            Ok(self.len())
                        }
                        _ => Err(Self::Error::IncompleteBuilder { builder }),
                    }
                }

                fn despawn(&mut self, index: Self::Index) -> Result<(), Self::Error> {
                    // Needs to be filled based on the actual logic of despawning.
                    unimplemented!()
                }
            }
        }
    };
}

#[cfg(test)]
mod test {
    use glam::{Mat4, Vec3};

    use crate::thing::{HealthFacet, Shape};
    use crate::Archetype;

    def_archetype_boilerplate! {
        Blob,
        a_field: u32
    }

    def_archetype_boilerplate! {
        Blob2,
        a_field: u32
    }

    def_archetype_boilerplate! {
        Player,
        gfx: super::super::index::GfxIndex,
        position: Vec3,
        view: Mat4,
        perspective: Mat4,
        angles: Vec3,
        scale: f32,
        linear_velocity_intention: Vec3,
        angular_velocity_intention: Vec3,
        shape: Shape,
        health: HealthFacet
    }

    #[test]
    fn instantiate_archetype() {
        let mut blob_archetype: BlobArchetype = BlobArchetype::default();

        let mut builder = blob_archetype.builder();

        builder.set_a_field(42);
        blob_archetype.set_default_builder(builder.clone());

        let mut blob_iter = blob_archetype.iter_mut();
        for blob_ref in blob_iter {
            assert_eq!(*blob_ref.a_field, 42);
            *blob_ref.a_field = 43;
            assert_eq!(*blob_ref.a_field, 43);
        }

        let index = blob_archetype.spawn(builder).unwrap();

        let blob_ref = blob_archetype.get_mut(index).unwrap();
        assert_eq!(*blob_ref.a_field, 43);
    }

    #[test]
    fn instantiate_error() {
        let blob_archetype: BlobArchetype = BlobArchetype::default();
        let builder = blob_archetype.builder();
        let err_str = format!(
            "{}",
            BlobError::IncompleteBuilder {
                builder: builder.clone()
            }
        );
        assert_eq!(
            err_str,
            "BlobArchetype builder is incomplete BlobBuilder { a_field: None }"
        );
    }
}
